#!/bin/env python3
#
# Generate/read probabilities of starting state
# for given 8 bit output sequence. Each bit is
# four bits apart and retrieved after splitting
# even/odd sequence.
#
# Elliot Buller
# 2022
#

from Crypto1 import *
import argparse
import json

# Convert initial state to index
ilookup = [[0, 2, 4, 5, 6, 7, 8, 9, 10, 12, 19, 21, 23, 24, 25, 28],
           [1, 3, 11, 13, 14, 15, 16, 17, 18, 20, 22, 26, 27, 29, 30, 31]]

def XOR (key):
    return key[47] ^ key[42] ^ key[38] ^ key[37] ^ key[35] ^ key[33] ^ \
        key[32] ^ key[30] ^ key[28] ^ key[23] ^ key[22] ^ key[20] ^ \
        key[18] ^ key[12] ^ key[8] ^ key[6] ^ key[5] ^ key[4]

# Rewind state 45 cycles
def Rewind (key):
    state = int2binarr (key, 48)[::-1]
    for n in range (45):
        a = state[0]
        state = state[1:48] + [0]
        state[47] = XOR(state) ^ a
    return binarr2int (state[::-1])

class Crypto1Prob:

    def __init__ (self, json_file, bitstream=[0]*64):

        if len (bitstream) != 64:
            print ('Must supply 64bit bitstream')
            raise ValueError
        
        # Read json file, load probability list
        with open (json_file, 'r') as fp:
            self.plist = json.load (fp)

        # Extract even/odd from bitstream
        even = bitstream[0::2]
        odd = bitstream[1::2]

        # Trim to every 4 bits
        even = even[0::4]
        odd = odd[0::4]

        # Get probabilities
        self.even = self.plist[binarr2int (even)]
        self.odd = self.plist[binarr2int (odd)]

        # Sort into search space
        self.search = []
        for i in range (16):
            for j in range (16):
                self.search.append ([self.even[i] * self.odd[j], i, j])

        # Sort descending
        self.search = sorted (self.search, key=lambda x: x[0])[::-1]

    # Return index (0-255) of even/odd
    def index (self, e, o):
        for n in range (256):
            if (self.search[n][1] == e) and (self.search[n][2] == o):
                return n

    # Loop through table to generate fixed point
    def gen_c (self):

        # Create list, find min/max
        vmin = 1.0
        vmax = 0
        l = []
        for x in self.plist:
            for y in x:
                if y < vmin:
                    vmin = y
                if y > vmax:
                    vmax = y

        # Calculate range and step
        vrange = vmax - vmin
        vstep = vrange / 256
        #print ('min={} max={} range={} step={}'.format (vmin, vmax, vrange, vstep))

        # Print out C header
        _ = ''
        _ += '// Generated by CalcProb.py : do not edit!\n\n'
        _ += '#ifndef CRYPTO1_PROB_H\n'
        _ += '#define CRYPTO1_PROB_H\n'
        _ += 'const uint8_t c1_prob [256][16] = {\n'
        for x in self.plist:
            _ += '{'
            for y in x:
                v = round ((y - vmin) / vstep)
                if v > 255:
                    v = 255
                _ += '0x{:02x}, '.format (v)
            _ = _[:-2] + '},\n'
        _ += '};\n'
        _ += '#endif /* CRYPTO1_PROB_H */\n'
        print (_)
        
if __name__ == '__main__':

    parser = argparse.ArgumentParser ()
    parser.add_argument ('--gen_cnt', type=int,
                         help='Generate json file containing index probabilities')
    parser.add_argument ('--gen_c', action='store_true',
                         help='Generate C header from json file')
    parser.add_argument ('--get_idx', type=str,
                         help='Get even/odd index for bitstream')
    parser.add_argument ('--get_random', action='store_true',
                         help='Get random valid key and indices')
    parser.add_argument ('--rewind', type=str,
                         help='Rewind key 45 cycles')
    parser.add_argument ('--sample', type=int,
                         help='Sample n random keys, show average time to solve')
    args = parser.parse_args ()


    # Generate pickle file
    if args.gen_cnt:

        # Create array of counts based on random key/output pair
        cnt = [[0] * 32 for x in range (256)]

        # Execute given sample size
        for n in range (args.gen_cnt):
            
            # Use random num gen to create key
            cipher = Crypto1 (state=random.randint (1, 2**48))

            # Get 64 bit output
            out = cipher.Raw (64)

            # Extract bits corresponding to even NLF ops
            even = out[0::2]

            # Take every 4th bit from that
            bits = even[0::4]

            # Convert to 8 bit int
            idx = binarr2int (bits)

            # Get initial NLFC(input) as int
            val = binarr2int (cipher.Start ())

            # Store in array
            cnt[idx][val] += 1

        # Convert to list of probabilities
        # Index will be output bits
        # 16 list elements will contain the
        # float probabilites of the 16 starting
        # inputs to NLFC
        store = [[0] * 16 for x in range (256)]
        idx = 0
        for e in cnt:

            # Convert sparse array to compact array
            i = 0
            
            # Generate sum
            s = sum (e)

            # Normalize each value
            for v in e:
                if v:
                    store[idx][i] = v / s
                    i += 1

            # Increment output index
            idx += 1
            
        # Create output file
        with open ('crypto1_prob.json', 'w') as fp:

            # Write out json
            json.dump (store, fp)
            
    # Generate C header from pickle file
    elif args.gen_c:

        # Create object
        prob = Crypto1Prob ('crypto1_prob.json')
        prob.gen_c ()
        
    elif args.get_random:
        # Use random num gen to create key
        key = hex(random.randint (1, 2**48))
        args.get_idx = key

    elif args.rewind:
        # Rewind key
        key = int (args.rewind, 0)
        print ('Key={}'.format (hex(Rewind (key))))
        
    # Get even/odd index for key
    if args.get_idx:

        print ('Key={}'.format (args.get_idx))

        # Get bitstream
        cipher = Crypto1 (state=int(args.get_idx, 0))
        bs = cipher.Raw (64)

        # Create
        cipher = Crypto1 (state=int(args.get_idx, 0))

        # Get first output bit
        out0 = cipher.Raw (1)[0]

        # Get even idx
        eidx = ilookup[out0].index (binarr2int(cipher.Start ()))
        print ('Even={}'.format (eidx))

        # Move one bit forward and get state
        cipher = Crypto1 (state=binarr2int(cipher.State()))

        # Get first output bit
        out0 = cipher.Raw (1)[0]
        
        # Get even idx
        oidx = ilookup[out0].index (binarr2int(cipher.Start ()))

        # Get odd idx
        print ('Odd={}'.format (oidx))

        # Print bitstream
        print ('Bitstream={}'.format (hex (binarr2int (bs))))

        # Get probability
        prob = Crypto1Prob ('crypto1_prob.json', bs)

        # Print index
        print ('Solution found at {:.2f}%'.format (prob.index (eidx, oidx)/255 * 100))

    # Get even/odd index for key
    if args.sample:

        avg = float ()
        
        for n in range (args.sample):
            key = hex(random.randint (1, 2**48))

            # Get bitstream
            cipher = Crypto1 (state=int(key, 0))
            bs = cipher.Raw (64)

            # Create
            cipher = Crypto1 (state=int(key, 0))

            # Get first output bit
            out0 = cipher.Raw (1)[0]

            # Get even idx
            eidx = ilookup[out0].index (binarr2int(cipher.Start ()))

            # Move one bit forward and get state
            cipher = Crypto1 (state=binarr2int(cipher.State()))

            # Get first output bit
            out0 = cipher.Raw (1)[0]
        
            # Get even idx
            oidx = ilookup[out0].index (binarr2int(cipher.Start ()))

            # Get probability
            prob = Crypto1Prob ('crypto1_prob.json', bs)

            # Calc time to solve
            tts = prob.index (eidx, oidx) / 255 * 100
            avg += tts

        # Get average tts
        avg = avg / args.sample
        print ('Average time to solve: {:.2f}%'.format (avg))
